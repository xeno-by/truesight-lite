This page is about node types that are implemented in Truesight and about how they map onto basic semantic concepts of high-level languages. If you'd like to check out generic questions of designing the AST, visit [AstDesign](AstDesign.md). Some philosophic considerations of designing HIR are covered in [HirDesign](HirDesign.md). Finally, you might also be interested in visiting [InAction](InAction.md) which discusses a case study of using Truesight for a real world task.

| **Semantics** | **Truesight's idiom** |
|:--------------|:----------------------|
| Reading a variable | `Ref(sym)`. Ref node has the `Sym` property that represents referenced variable. The `Sym` can be either of type `Local` or of type `Param`. One can distinguish between those subtypes by using `IsLocal` and `IsParam` extension methods. `Syms` feature name, type and a couple of ids. |
| Reading a by-ref parameter | `Ref(param)`. CLR expresses by-ref semantics with the use of pointers (though `T&` and `T*` are different types in CLR, they're read/written by using `ldind.*`/`stind.*` instructions (names stand for LoaD/STore INDirect)). However, pointer semantics for by-ref variables is an implementation detail, so Truesight gets rid of it. |
| Reading memory addressed by a pointer | `Deref(ptr)`. The idiom and supporting HIR nodes is in place, though Truesight doesn't currently support pointers. |
| Writing a variable | `Assign(Ref(sym), rhs)`. |
| Writing a by-ref variable | `Assign(Ref(param), rhs)`. Cf. "Writing to a memory addressed by a pointer". |
| Writing to a memory addressed by a pointer | `Assign(Deref(ptr), rhs)`. The idiom and supporting HIR nodes is in place, though Truesight doesn't currently support pointers. |
| Reading a field | `Fld(fieldInfo, this)`. `Fld` node has two properties - `Field` references corresponding `FieldInfo` and `This` represents the lhs of the member access (it must be null if the field is static). `Fld` is a subtype of a `Slot` - an abstract class that serves as a base for both field and property access idioms. |
| Writing a field | `Assign(Fld(fieldInfo, this), rhs)`. |
| Reading a property | `Prop(propertyInfo, this)` or `Apply(Prop(propertyInfo, this)), indexerArgs)` or an equivalent `Eval(...)`. Similarly to the `Fld` node, `Prop` provides access to its `PropertyInfo` and the lhs of member access. However, it features two additional details. Firstly, indexers (properties with parameters) are represented in an extravagant manner (though this way is consistent with functional notions in Truesight). Secondly, since properties in CLR are nothing more than a thin abstraction layer of getter and setter methods, reading a property can be represented by an equivalent `Eval` node. To provide common denominator for such a variety of ways to express property access semantics, Truesight features several extension methods, e.g. `InvokedProp` and `InvocationIndexers` (there are some more - please, refer to the code). |
| Writing a property | `Assign(Prop(propertyInfo, this), rhs)` or `Assign(Apply(Prop(propertyInfo, this)), indexerArgs), rhs)` or an equivalent `Eval(...)`. |
| Invoking a method | `Eval(Apply(Lambda(methodInfo), args))`. Quite a verbose way to say the same thing as is expressed, e.g. by the `MethodCallExpression` of `System.Linq`, isn't it? However, it has certain rationale. First, since from the very start I've aimed at supporting lambdas (anonymous delegates), I've needed to the `Lambda` abstraction as opposing to, say, plain `MethodInfo` (or `MethodBase`) that represents the invocaton. Secondly, to support `ldftn` instructions I needed a notion of partial application - here's when the `Apply` node was introduced. Finally, I needed to differentiate partial application that leads to creating a lambda with no args and evaluation of a method. These two cannot be distinguished by `Apply` alone, so I've introduced the `Eval` node. This differs from the approach used in classic lambda calculus, since in CLR values and functions are qualitatively different entities. To quickly disassemble this structure of nodes you can use `InvokedMethod` and `InvocationArgs` extension methods (there are some more helpers - please, refer to the code). |
| Invoking a static method | `Eval(Apply(Lambda(methodInfo), args))`, where `args` represent normal parameters that you supply in brackets when calling method from C#. Notion of extension methods is just a syntactic over static methods, so in Truesight they're represented in the same way. |
| Invoking an instance method | `Eval(Apply(Lambda(methodInfo), args))`. Here `args` also include the `arg0`, which is the `this` argument of the invocation. Things are getting messy, so I've introduced a way to uniformly find out which `arg` corresponds to which `ParameterInfo` of the invocation. The `Apply` node features the `ArgsInfo` dictionary that correctly works for all types of invocations, also I'm going to add the `InvocationArgsInfo` extension method that can be invoked on any of the nodes that represent the invocation. |
| Virtually invoking an instance method | `Eval(Apply(Lambda(methodInfo), args))`. Everything said above applies to this idiom with a single addition. Virtuality of a certain invocation is stored in the `Lambda` node - you can check it by reading the `InvokedAsVirtual` flag property. An arguable design decision, however, it doesn't prove to create incoveniences so far. |
| Invoking a constructor | `Eval(Apply(Lambda(constructorInfo), args))`. Here `args` don't include the `arg0`, so this works consistently with C# semantics. You can distinguish constructor invocation from a regular invocation by examining the `InvokedAsCtor` flag property of the `Lambda`. Everything is simple, ain't it? Not so fast. Decompiled body of the constructor certainly needs to reference the `arg0`, so we need to store it somewhere. From the other side, we need to be consistent with the `args -> new instance` semantics of constructors. This is resolved internally within the `Sig` of the `Lambda`. `Sig` features two distinct (though consistent) ways to represent parameters - `Params` feature names and types of parameters (they're mostly just wrapped `ParameterInfos`), whereas `Symbols` feature a collection of `Sym`s that can be referenced withing constructor's body. So, `Params` don't include the `arg0`, while `Symbols` always include it. Quite tricky to handle in you code? Not really if you use the aforementioned `ArgsInfo` or the `InvocationArgsInfo` methods - it takes care of all those details. |
| Invoking `base`/`this` constructor | `Eval(Apply(Lambda(constructorInfo), args))`. Unlike in the previous case, this invocation has normal instance method invocation semantics, so the `args` collection does include the `arg0`. To differentiate from constructor invocation semantics, refer to the `InvokedAsCtor` flag property of the `Lambda` - in this case it's set to `false`. |
| Invoking a varargs method | `Eval(Apply(Lambda(methodInfo), args))`, where the last entry in the `args` collection is `CollectionInit(szArrayCtor, varargs)`. This idiom closely follows C#'s way of handling the `varargs` semantics (but is different from how the low-level `varargs` calling convention works in CLR!). |
| Passing argument by value | `arg` within the `Apply` node. Just as you would expect it to work. |
| Passing argument by reference | `arg` within the `Apply` node. One would expect `Addr(arg)` here, but, as mentioned above, despite that CLR implements by-ref semantics by using pointers, Truesight abstracts away from this implementation detail. This certainly complicates life for the back-end, however, it significantly simplifies code analysis. To find out whether the argument is passed by-ref you may use aforementioned `ArgsInfo` map and check the type of the parameter mapped to the argument. To find out whether method's parameter is passed by argument, use the `InferType` extension method or `Sig`'s `Params` and check the `IsByRef` property of corresponding `Type`. |

I think, it's time to stop here. Despite that we have like 10-20 more nodes, they're pretty self-explaining and work intuitively. E.g. `If` features `Test`, `IfTrue` and `IfFalse`, whereas `Goto` features an id of the `Label` it jumps to. The only non-obvious to me node is `Iter` that, I think, is a better name for the `ForEach` idiom.

Finally, please remember the following thingies. Firstly, most high-level concepts are still not implemented (e.g. `using`s, `foreach`es, lambdas/closures decompilation, generators and so on), so just having certain `Node` in place doesn't imply that the decompiler correctly decompiles it. Secondly, things here might be changed in code, but I might be late to update them in time. So, finally, take a look at the [InAction](InAction.md) wiki page and then just grab the code and take a look at how things work. The code is always more up to date than the documentation and, what's more - it never lies =)